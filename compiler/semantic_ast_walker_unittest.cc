// Gunderscript 2 Semantic (type) Checker for AST Unit Test
// (C) 2015-2016 Christian Gunderman

#include "gtest/gtest.h"
#include "testing_macros.h"

#include "gunderscript/node.h"

#include "lexer.h"
#include "parser.h"
#include "semantic_ast_walker.h"

using namespace gunderscript;
using gunderscript::compiler::Lexer;
using gunderscript::compiler::Parser;
using gunderscript::compiler::SemanticAstWalker;

// This module tests the semantic checker layer for Gunderscript 2.
// The tests cover only the expected positive and negative cases from
// ASTs generated by the parser and do not check for the STATUS_ILLEGAL_STATE
// thrown by invalid ASTs. This is done intentionally since the STATUS_ILLEGAL_STATE
// are there for the purpose of debug assertions.

TEST(SemanticAstWalker, ModuleNameTrailingPeriodThrows) {
    std::string input("package \"Gundersoft.\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleNameEmptyThrows) {
    std::string input = std::string("package \"\";");
    CompilerStringSource source(input);

    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleNameOnlyPeriodThrows) {
    std::string input("package \".\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleNameStartsWithPeriodThrows) {
    std::string input("package \".Hello\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleDependsNameTrailingPeriodThrows) {
    std::string input(
        "package \"Gundersoft\";"
        "depends \"Gundersoft.\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleDependsNameEmptyThrows) {
    std::string input(
        "package \"Gundersoft\";"
        "depends \"\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleDependsNameOnlyPeriodThrows) {
    std::string input(
        "package \"Gundersoft\";"
        "depends \".\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleDependsNameStartsWithPeriodThrows) {
    std::string input(
        "package \"Gundersoft\";"
        "depends \".Foo\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, SpecDuplicateDefinition) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test { } "
        "public spec Test { }");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_SPEC);
    delete root;
}

TEST(SemanticAstWalker, FunctionDuplicateDefinition) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main(int32 x, string y) { }"
        "    public int32 main(int32 x, string y) { }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_FUNCTION);
    delete root;
}

TEST(SemanticAstWalker, StaticFunctionDuplicateDefinition) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 main(int32 x, string y) { }"
        "public int32 main(int32 x, string y) { }");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_FUNCTION);
    delete root;
}

TEST(SemanticAstWalker, AutoPropertyDuplicateDefinition) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    int32 Y { concealed get; concealed set; }"
        "    int32 Y { public get; public set; }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_PROPERTY);
    delete root;
}

TEST(SemanticAstWalker, PropertyWithBodyDuplicateDefinition) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    int32 Y { concealed get { } concealed set { } }"
        "    int32 Y { public get { } public set { } }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);
    
    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_PROPERTY);
    delete root;
}

TEST(SemanticAstWalker, MixedAutoAndExpandedProperties) {
    // Case 1:
    {
        std::string input(
            "package \"Gundersoft\";"
            "public spec Test {"
            "    int32 Y { concealed get { } concealed set; }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }

    // Case 2:
    {
        std::string input(
            "package \"Gundersoft\";"
            "public spec Test {"
            "    int32 Y { concealed get; concealed set { } }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }
}

TEST(SemanticAstWalker, FunctionCallWithInvalidParameter) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main(string x) { main(3); }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_FUNCTION_OVERLOAD_NOT_FOUND);
    delete root;
}

TEST(SemanticAstWalker, FunctionCallWithInvalidParameterStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 main(string x) { main(3); }");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_FUNCTION_OVERLOAD_NOT_FOUND);
    delete root;
}

TEST(SemanticAstWalker, FunctionCallNeedingTypecastedParameter) {
    // Gunderscript does not allow autoboxing from int to float32.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main(float32 x) { main(3); }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_FUNCTION_OVERLOAD_NOT_FOUND);
    delete root;
}

TEST(SemanticAstWalker, FunctionCallNeedingTypecastedParameterStatic) {
    // Gunderscript does not allow autoboxing from int to float32.
    std::string input(
        "package \"Gundersoft\";"
        "public int32 main(float32 x) { main(3); }");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_FUNCTION_OVERLOAD_NOT_FOUND);
    delete root;
}

TEST(SemanticAstWalker, FunctionOverloads) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main(int32 x) { }"
        "    public int32 main() { }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionOverloadsStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 main(int32 x) { }"
        "public int32 main() { }");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, DuplicateFunctions) {
    // Case 1: same params and different return type.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public spec Test {"
            "    public int32 main(int32 x) { }"
            "    public float32 main(int32 x) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_FUNCTION);
        delete root;
    }

    // Case 2: different same params AND return type.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public spec Test {"
            "    public int32 main(int32 x) { }"
            "    public int32 main(int32 x) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_FUNCTION);
        delete root;
    }
}

TEST(SemanticAstWalker, DuplicateFunctionsStatic) {
    // Case 1: same params and different return type.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int32 main(int32 x) { }"
            "public float32 main(int32 x) { }");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_FUNCTION);
        delete root;
    }

    // Case 2: different same params AND return type.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int32 main(int32 x) { }"
            "public int32 main(int32 x) { }");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_FUNCTION);
        delete root;
    }
}

TEST(SemanticAstWalker, FunctionAndPropertyAndVariableShareName) {
    // Check to make sure there are no collisions between symbols of different types.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() {"
        "        X <- 3;"
        "    }"
        "    int32 X { public get; public set; }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionParamTypeSymbols) {
    // Check to make sure that the Function Param symbols are being defined and are usable.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 X, int32 Y) {"
        "        X <- X + Y;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionParamTypeSymbolsStatic) {
    // Check to make sure that the Function Param symbols are being defined and are usable.
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(int32 X, int32 Y) {"
        "    X <- X + Y;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionParamSymbolTypeReassign) {
    // Function params are declared in different scope than function variables and therefore
    // can be masked via reassignment. Masked variables take different types.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 X, int32 Y) {"
        "        X <- 3.0;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionParamSymbolTypeReassignStatic) {
    // Function params are declared in different scope than function variables and therefore
    // can be masked via reassignment. Masked variables take different types.
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(int32 X, int32 Y) {"
        "    X <- 3.0;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, AttemptCrossTypeOperations) {
    // Cannot evaluate operations across types without explicit typecast.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 X, int32 Y) {"
        "        X <- 3.0;"
        "        Y <- X + 1;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNMATCHING_TYPE_IN_ADD);
    delete root;
}

TEST(SemanticAstWalker, AttemptCrossTypeOperationsStatic) {
    // Cannot evaluate operations across types without explicit typecast.
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(int32 X, int32 Y) {"
        "    X <- 3.0;"
        "    Y <- X + 1;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNMATCHING_TYPE_IN_ADD);
    delete root;
}

TEST(SemanticAstWalker, AttemptTypeReassignment) {
    // Once a variable is declared, its type is final and cannot be changed until it goes out of scope.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 X, int32 Y) {"
        "        X <- 3.0;"
        "        Y <- X;"
        "        Y <- 1;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_TYPE_MISMATCH_IN_ASSIGN);
    delete root;
}

TEST(SemanticAstWalker, AttemptTypeReassignmentStatic) {
    // Once a variable is declared, its type is final and cannot be changed until it goes out of scope.
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(int32 X, int32 Y) {"
        "    X <- 3.0;"
        "    Y <- X;"
        "    Y <- 1;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_TYPE_MISMATCH_IN_ASSIGN);
    delete root;
}

TEST(SemanticAstWalker, FunctionsOutOfOrder) {
    // Check to make sure that functions can call one another out of order.
    // This tests the prescan.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() {"
        "        Y();"
        "        X();"
        "    }"
        "    public int32 Y() {"
        "        Y();"
        "        X();"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionsOutOfOrderStatic) {
    // Check to make sure that functions can call one another out of order.
    // This tests the prescan.
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X() {"
        "    Y();"
        "    X();"
        "}"
        "public int32 Y() {"
        "    Y();"
        "    X();"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionCorrectReturnStatement) {
    // Check for no exception when function returns correctly.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() {"
        "        return 3 + 4;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionCorrectReturnStatementStatic) {
    // Check for no exception when function returns correctly.
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X() {"
        "    return 3 + 4;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionIncorrectReturnStatement) {
    // Check for exception when function returns incorrect type.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() {"
        "        return true;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_TYPE_MISMATCH);
    delete root;
}

TEST(SemanticAstWalker, FunctionIncorrectReturnStatementStatic) {
    // Check for exception when function returns incorrect type.
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X() {"
        "    return true;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_TYPE_MISMATCH);
    delete root;
}

TEST(SemanticAstWalker, BlockStatementScoping) {
    // Check that variables are scoped by block without being replaced.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() { "
        "        X <- 1;"
        "        { X <- true; } "
        "        X <- 2;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, BlockStatementScopingStatic) {
    // Check that variables are scoped by block without being replaced.
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X() { "
        "    X <- 1;"
        "    { X <- true; } "
        "    X <- 2;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, PropertyReturnCorrectly) {
    // Check that returning correctly from a property does not throw.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    int32 X {"
        "        public get { return 0; }"
        "        public set { }"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, PropertyReturnFromSet) {
    // Check that returning from a setter does throw.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    int32 X {"
        "        public get { return 0; }"
        "        public set { return 0; }"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_FROM_PROPERTY_SET);
    delete root;
}

TEST(SemanticAstWalker, PropertyReturnInvalidType) {
    // Check that we throw if we try to return invalid type from a property.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    int32 X {"
        "        public get { return true; }"
        "        public set { }"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_TYPE_MISMATCH);
    delete root;
}

TEST(SemanticAstWalker, AddInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 x) {"
        "        main(3 + 3.0);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNMATCHING_TYPE_IN_ADD);
    delete root;
}

TEST(SemanticAstWalker, AddInvalidTypeStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(int32 x) {"
        "    main(3 + 3.0);"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNMATCHING_TYPE_IN_ADD);
    delete root;
}

TEST(SemanticAstWalker, AddString) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(string x) {"
        "        X(\"sfsf\" + \"sfsf\");"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, AddStringStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(string x) {"
        "    X(\"sfsf\" + \"sfsf\");"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, AddBool) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- true + true;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_TYPE_IN_ADD);
    delete root;
}

TEST(SemanticAstWalker, AddBoolStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(bool x) {"
        "    x <- true + true;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_TYPE_IN_ADD);
    delete root;
}

TEST(SemanticAstWalker, SubtractString) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(string x) {"
        "        x <- \"sfsf\" - \"sfsf\";"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, SubtractStringStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(string x) {"
        "    x <- \"sfsf\" - \"sfsf\";"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, ModString) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(string x) {"
        "        x <- \"sfsf\" % \"sfsf\";"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, ModStringStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(string x) {"
        "    x <- \"sfsf\" % \"sfsf\";"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, MulInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- true * true;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, MulInvalidTypeStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(bool x) {"
        "    x <- true * true;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, DivInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- true / true;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, DivInvalidTypeStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(bool x) {"
        "    x <- true / true;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, AndInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- 3 && 3;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONBOOL_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, AndInvalidTypeStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(bool x) {"
        "    x <- 3 && 3;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONBOOL_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, OrInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- 3.0 || 3.0;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONBOOL_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, OrInvalidTypeStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(bool x) {"
        "    x <- 3.0 || 3.0;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONBOOL_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, GreaterInvalidTypeStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(bool x) {"
        "    x <- true > false;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, LessInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- true < false;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, LessInvalidTypeStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "    public int32 X(bool x) {"
        "        x <- true < false;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, GreaterEqualsInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(string x) {"
        "        x <- \"h\" >= \"d\";"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, GreaterEqualsInvalidTypeStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(string x) {"
        "        x <- \"h\" >= \"d\";"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}


TEST(SemanticAstWalker, LessEqualsInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(string x) {"
        "    x <- \"h\" <= \"d\";"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, FunctionInAssign) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        foo <- X(true);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionInAssignStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(bool x) {"
        "    foo <- X(true);"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastIntToInt) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int32(3);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastIntToIntStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 main() {"
        "    foo <- int32(3);"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastIntToFloat) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- float32(3);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastIntToChar) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int8(3);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastIntToBool) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- bool(3);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastFloatToFloat) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- float32(3.0);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastFloatToInt) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int32(3.0);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastFloatToBool) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- bool(3.0);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNSUPPORTED_TYPECAST);
    delete root;
}

TEST(SemanticAstWalker, TypecastFloatToChar) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int8(3.0);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastBoolToBool) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- bool(true);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastBoolToFloat) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- float32(true);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastBoolToChar) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int8(true);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastBoolToInt) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int32(true);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastCharToBool) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- bool('x');"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastCharToFloat) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- float32('x');"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastCharToInt) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int32('x');"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastCharToChar) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int8('x');"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

// TODO: support this in the future, but not yet.
TEST(SemanticAstWalker, TypecastStringToInt) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int32(\"sfsf\");"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNSUPPORTED_TYPECAST);
    delete root;
}

TEST(SemanticAstWalker, Combined) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        X( ((-(-1+2) / 3)) > (0 * (4 % -5)) || !(!(3 < 2)) && (4 >= 5) && (1 <= 6));"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, CombinedStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int32 X(bool x) {"
        "    X( ((-(-1+2) / 3)) > (0 * (4 % -5)) || !(!(3 < 2)) && (4 >= 5) && (1 <= 6));"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, AddChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int8 X() {"
        "        return 'x' + 'x';"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, SubChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int8 X() {"
        "        return 'x' - int8(7);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, MulChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int8 X() {"
        "        return int8(2.5 + float32(4)) * 'z';"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, DivChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int8 X() {"
        "        return '0' / int8(2);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, ModChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() {"
        "        return int32('0') % 2;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, StoreAndLoadChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int8 X() {"
        "        x <- 'q';"
        "        y <- x;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, StoreAndLoadCharsStatic) {
    std::string input(
        "package \"Gundersoft\";"
        "public int8 X() {"
        "    x <- 'q';"
        "    y <- x;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, CallStaticFromMember) {

    // Case 1: Function comes after spec.
    {
        std::string input(
            "package \"Gundersoft\"; "
            "public spec Test {"
            "    public int32 X() {"
            "        return Y(3, 2);"
            "    } "
            "} "
            "public int32 Y(int32 x, int32 y) {"
            "    return 1;"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }

    // Case 2: Function comes before spec.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int32 Y(int32 x, int32 y) {"
            "    return 1;"
            "} "
            "public spec Test {"
            "    public int32 X() {"
            "        return Y(3, 2);"
            "    }"
            "}"
            );
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }
}

TEST(SemanticAstWalker, IfStatementCorrectConditionType) {
    std::string input(
        "package \"Gundersoft\";"
        "public int8 X() {"
        "    if (true) { } else { }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, IfStatementIncorrectConditionType) {
    std::string input(
        "package \"Gundersoft\";"
        "public int8 X() {"
        "    if (3) { } else { }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_IF_CONDITION_TYPE);
    delete root;
}

// Checks to make sure that return type is still checked in if/else body, and by
// extension that types are checked in the blocks.
TEST(SemanticAstWalker, IfStatementReturnTypeChecking) {
    // Case 1: Bad return type in if.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int8 X() {"
            "    if (true) { return false; } else { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_TYPE_MISMATCH);
        delete root;
    }
    
    // Case 2: Bad return type in else.
    // Due to the structure of the AST, if this test passes we know that type checking also
    // works for else/if as well.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int8 X() {"
            "    if (true) { } else { return false; }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_TYPE_MISMATCH);
        delete root;
    }
}

TEST(SemanticAstWalker, ForStatementInitSemanticError) {
    std::string input(
        "package \"Gundersoft\";"
        "public int8 X() {"
        "    x <- 1;"
        "    for (x <- 1.0;;) { }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_TYPE_MISMATCH_IN_ASSIGN);
    delete root;
}

TEST(SemanticAstWalker, ForStatementCondInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public int8 X() {"
        "    x <- 1;"
        "    for (;3;) { }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_LOOP_CONDITION_TYPE);
    delete root;
}

TEST(SemanticAstWalker, ForStatementCondSemanticError) {
    std::string input(
        "package \"Gundersoft\";"
        "public int8 X() {"
        "    x <- 1;"
        "    for (;x < 1.0;) { }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNMATCHING_TYPE_IN_LESS);
    delete root;
}

TEST(SemanticAstWalker, ForStatementUpdateSemanticError) {
    std::string input(
        "package \"Gundersoft\";"
        "public int8 X() {"
        "    x <- 1;"
        "    for (;;x <- 1.0) { }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_TYPE_MISMATCH_IN_ASSIGN);
    delete root;
}

TEST(SemanticAstWalker, ForStatementInvalidReturnType) {
    std::string input(
        "package \"Gundersoft\";"
        "public int8 X() {"
        "    for (;;) { return 0; }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_TYPE_MISMATCH);
    delete root;
}

TEST(SemanticAstWalker, CorrectForStatement) {
    // Case 1: No params.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int8 X() {"
            "    for (;;) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }

    // Case 2: Init only.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int8 X() {"
            "    for (x <- 1;;) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }

    // Case 3: Condition only.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int8 X() {"
            "    i <- 1;"
            "    for (;i < 10;) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }

    // Case 4: Update only.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int8 X() {"
            "    i <- 1;"
            "    for (;;i <- i + 1) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }

    // Case 5: Init and condition.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int8 X() {"
            "    for (i <- 1; i < 2;) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }

    // Case 6: Condition and update.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int8 X() {"
            "    i <- 1;"
            "    for (; i < 2; i <- i + 1) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }

    // Case 7: Init and update.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int8 X() {"
            "    for (i <- 1;; i <- i + 1) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }

    // Case 8: All.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public int8 X() {"
            "    for (i <- 1; i < 10; i <- i + 1) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }
}

TEST(SemanticAstWalker, UndefinedVariable) {
    std::string input(
        "package \"Gundersoft\";"
        "public int8 X() {"
        "    return X;"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNDEFINED_VARIABLE);
    delete root;
}

TEST(SemanticAstWalker, CorrectOutOfOrderSpec) {
    std::string input(
        "package \"Gundersoft\";"
        "public Foo NewFoo() { return new Foo(); }"
        "public spec Foo {"
        "    public construct() { }"
        "    public Foo2 NewFoo() { return new Foo2(); }"
        "}"
        "public spec Foo2 {"
        "    public construct() { }"
        "    public Foo NewFoo() { return new Foo(); }"
        "}"
        "public Foo2 NewFoo2() { return new Foo2(); }"
        );
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, CorrectOutOfOrderSpecWithGenerics) {
    std::string input(
        "package \"Gundersoft\";"
        "public Foo<Foo2<Foo<int32>, bool>> FooFunc() { }"
        "public spec Foo<T> { }"
        "public spec Foo2<U, V> { }"
        );
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, SpecGenericMissingParam) {
    std::string input(
        "package \"Gundersoft\";"
        "public Foo<Foo2<Foo>> FooFunc() { }"
        "public spec Foo<T> { }"
        "public spec Foo2<U> { }"
        );
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNDEFINED_TYPE);
    delete root;
}

TEST(SemanticAstWalker, SpecGenericExtraParam) {
    std::string input(
        "package \"Gundersoft\";"
        "public Foo<Foo2<Foo<int32, bool>>> FooFunc() { }"
        "public spec Foo<T> { }"
        "public spec Foo2<U> { }"
        );
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNDEFINED_TYPE);
    delete root;
}

TEST(SemanticAstWalker, SpecGenericParamCollidesWithType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec T { }"
        "public spec Foo<T> { }"
        );
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, SpecGenericDuplicateParam) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Foo<T, T> { }"
        );
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_GENERIC_DUPLICATE_PARAM);
    delete root;
}

// Ensures that generic params don't live beyond their specs.
TEST(SemanticAstWalker, SpecGenericParamLifetime) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Foo<T> { }"
        "public spec Foo2 { public T Foo() { } }"
        );
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNDEFINED_TYPE);
    delete root;
}

TEST(SemanticAstWalker, EndToEndNewGenericTestFailure) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Foo<T> {"
        "    public construct() { }"
        "}"
        "public Foo<int32> DoFoo(Foo<bool> x) {"
        "    y <- new Foo<bool>();"
        "    return y;"
        "}"
        );
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_TYPE_MISMATCH);
    delete root;
}

TEST(SemanticAstWalker, NestedTypeGenericTestFailure) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Foo<T> {"
        "    public construct() { }"
        "}"
        "public Foo<Foo<int32>> main() {"
        "    return new Foo<Foo<bool>>();"
        "}"
        );
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_TYPE_MISMATCH);
    delete root;
}

TEST(SemanticAstWalker, InvalidConstructorOverload) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Foo<T> {"
        "    public construct(int32 x) { }"
        "}"
        "public void Foo() { x <- new Foo<int32>(true); }"
        );
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_CONSTRUCTOR_OVERLOAD_NOT_FOUND);
    delete root;
}

TEST(SemanticAstWalker, EndToEndNewGenericTestPass) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Foo<T, U> {"
        "    public construct() { }"
        "    public Foo2<T, U> F1(Foo<T, U> x, Foo2<T, U> y) { }"
        "    public Foo<T, U> F2(Foo<T, U> x, Foo2<T, U> y) { }"
        "}"
        "public spec Foo2<T, U> {"
        "    public construct() { }"
        "    public construct(int32 x) { }"
        "    public Foo2<T, U> F1(Foo<T, U> x, Foo2<T, U> y) { }"
        "    public Foo<T, U> F2(Foo<T, U> x, Foo2<T, U> y) { }"
        "}"
        "public Foo<int32, bool> DoFoo(Foo<int32, bool> x) {"
        "    y <- new Foo<int32, bool>();"
        "    x <- new Foo2<int32, bool>();"
        "    z <- new Foo2<int32, bool>(34);"
        "    q <- new Foo<Foo<int32, bool>, Foo2<bool, bool>>();"
        "    return y;"
        "}"
        );
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, VoidFunctionCall) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 x) {"
        "       foo(3);"
        "    }"
        "    public void foo(int32 x) { y <- x; return; }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, VoidFunctionCallAttemptedReturn) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 x) {"
        "       foo(3);"
        "    }"
        "    public void foo(int32 x) { y <- x; return x; }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_IN_VOID);
    delete root;
}

TEST(SemanticAstWalker, VoidFunctionCallUsedInReturn) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 x) {"
        "       return foo(3);"
        "    }"
        "    public void foo(int32 x) {  }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_VOID_USED_IN_EXPR);
    delete root;
}

TEST(SemanticAstWalker, VoidFunctionCallUsedInExpr) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 x) {"
        "       foo(3 + foo(3));"
        "    }"
        "    public void foo(int32 x) {  }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_VOID_USED_IN_EXPR);
    delete root;
}

TEST(SemanticAstWalker, VoidFunctionCallAttemptedAssign) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 x) {"
        "       x <- foo(3);"
        "    }"
        "    public void foo(int32 x) {  }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_VOID_USED_IN_EXPR);
    delete root;
}

TEST(SemanticAstWalker, VoidFunctionCallUsedInCast) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 x) {"
        "       x <- int32(foo(3));"
        "    }"
        "    public void foo(int32 x) {  }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_VOID_USED_IN_EXPR);
    delete root;
}

TEST(SemanticAstWalker, VoidParamType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(void x) {"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_VOID_USED_IN_PARAM);
    delete root;
}

TEST(SemanticAstWalker, NewExprNonSpec) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public construct() { }"
        "    public int32 X() {"
        "        x <- new int32();"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_CONSTRUCTOR_OVERLOAD_NOT_FOUND);
    delete root;
}

TEST(SemanticAstWalker, NewExprInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public construct() { }"
        "    public int32 X() {"
        "        x <- new yolo_type();"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNDEFINED_TYPE);
    delete root;
}

TEST(SemanticAstWalker, DefaultExprCorrectUsage) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test<T> {"
        "    public construct() { }"
        "    public int32 X() {"
        "        x <- default(Test<T>);"
        "        y <- default(Test<int32>);"
        "        z <- default(int32);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, DefaultExprInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test<T> {"
        "    public construct() { }"
        "    public int32 X() {"
        "        z <- true;"
        "        z <- default(int32);"
        "        "
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_TYPE_MISMATCH_IN_ASSIGN);
    delete root;
}

TEST(SemanticAstWalker, FunctionAsType) {
    std::string input(
        "package \"Gundersoft\";"
        "public void Foo() { }"
        "public Foo MyFoo() { }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNDEFINED_TYPE);
    delete root;
}