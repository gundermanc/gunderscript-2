// Gunderscript 2 Semantic (type) Checker for AST Unit Test
// (C) 2015-2016 Christian Gunderman

#include "gtest/gtest.h"
#include "testing_macros.h"

#include "gunderscript/node.h"

#include "lexer.h"
#include "parser.h"
#include "semantic_ast_walker.h"

using namespace gunderscript;
using gunderscript::compiler::Lexer;
using gunderscript::compiler::Parser;
using gunderscript::compiler::SemanticAstWalker;

// This module tests the semantic checker layer for Gunderscript 2.
// The tests cover only the expected positive and negative cases from
// ASTs generated by the parser and do not check for the STATUS_ILLEGAL_STATE
// thrown by invalid ASTs. This is done intentionally since the STATUS_ILLEGAL_STATE
// are there for the purpose of debug assertions.

TEST(SemanticAstWalker, ModuleNameTrailingPeriodThrows) {
    std::string input("package \"Gundersoft.\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleNameEmptyThrows) {
    std::string input = std::string("package \"\";");
    CompilerStringSource source(input);

    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleNameOnlyPeriodThrows) {
    std::string input("package \".\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleNameStartsWithPeriodThrows) {
    std::string input("package \".Hello\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleDependsNameTrailingPeriodThrows) {
    std::string input(
        "package \"Gundersoft\";"
        "depends \"Gundersoft.\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleDependsNameEmptyThrows) {
    std::string input(
        "package \"Gundersoft\";"
        "depends \"\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleDependsNameOnlyPeriodThrows) {
    std::string input(
        "package \"Gundersoft\";"
        "depends \".\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, ModuleDependsNameStartsWithPeriodThrows) {
    std::string input(
        "package \"Gundersoft\";"
        "depends \".Foo\";");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_PACKAGE);

    delete root;
}

TEST(SemanticAstWalker, SpecDuplicateDefinition) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test { } "
        "public spec Test { }");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_SPEC);
    delete root;
}

TEST(SemanticAstWalker, FunctionDuplicateDefinition) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main(int32 x, string y) { }"
        "    public int32 main(int32 x, string y) { }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_FUNCTION);
    delete root;
}

TEST(SemanticAstWalker, AutoPropertyDuplicateDefinition) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    int32 Y { concealed get; concealed set; }"
        "    int32 Y { public get; public set; }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_PROPERTY);
    delete root;
}

TEST(SemanticAstWalker, PropertyWithBodyDuplicateDefinition) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    int32 Y { concealed get { } concealed set { } }"
        "    int32 Y { public get { } public set { } }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);
    
    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_PROPERTY);
    delete root;
}

TEST(SemanticAstWalker, MixedAutoAndExpandedProperties) {
    // Case 1:
    {
        std::string input(
            "package \"Gundersoft\";"
            "public spec Test {"
            "    int32 Y { concealed get { } concealed set; }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }

    // Case 2:
    {
        std::string input(
            "package \"Gundersoft\";"
            "public spec Test {"
            "    int32 Y { concealed get; concealed set { } }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_NO_THROW(semantic_walker.Walk());
        delete root;
    }
}

TEST(SemanticAstWalker, FunctionCallWithInvalidParameter) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main(string x) { main(3); }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_FUNCTION_OVERLOAD_NOT_FOUND);
    delete root;
}

TEST(SemanticAstWalker, FunctionCallNeedingTypecastedParameter) {
    // Gunderscript does not allow autoboxing from int to float32.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main(float32 x) { main(3); }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_FUNCTION_OVERLOAD_NOT_FOUND);
    delete root;
}

TEST(SemanticAstWalker, FunctionOverloads) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main(int32 x) { }"
        "    public int32 main() { }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, DuplicateFunctions) {
    // Case 1: same params and different return type.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public spec Test {"
            "    public int32 main(int32 x) { }"
            "    public float32 main(int32 x) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_FUNCTION);
        delete root;
    }

    // Case 2: different same params AND return type.
    {
        std::string input(
            "package \"Gundersoft\";"
            "public spec Test {"
            "    public int32 main(int32 x) { }"
            "    public int32 main(int32 x) { }"
            "}");
        CompilerStringSource source(input);
        Lexer lexer(source);
        Parser parser(lexer);

        Node* root = parser.Parse();

        SemanticAstWalker semantic_walker(*root);

        EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_DUPLICATE_FUNCTION);
        delete root;
    }
}

TEST(SemanticAstWalker, FunctionAndPropertyAndVariableShareName) {
    // Check to make sure there are no collisions between symbols of different types.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() {"
        "        X <- 3;"
        "    }"
        "    int32 X { public get; public set; }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionParamTypeSymbols) {
    // Check to make sure that the Function Param symbols are being defined and are usable.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 X, int32 Y) {"
        "        X <- X + Y;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionParamSymbolTypeReassign) {
    // Function params are declared in different scope than function variables and therefore
    // can be masked via reassignment. Masked variables take different types.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 X, int32 Y) {"
        "        X <- 3.0;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, AttemptCrossTypeOperations) {
    // Cannot evaluate operations across types without explicit typecast.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 X, int32 Y) {"
        "        X <- 3.0;"
        "        Y <- X + 1;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNMATCHING_TYPE_IN_ADD);
    delete root;
}

TEST(SemanticAstWalker, AttemptTypeReassignment) {
    // Once a variable is declared, its type is final and cannot be changed until it goes out of scope.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 X, int32 Y) {"
        "        X <- 3.0;"
        "        Y <- X;"
        "        Y <- 1;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_TYPE_MISMATCH_IN_ASSIGN);
    delete root;
}

TEST(SemanticAstWalker, FunctionsOutOfOrder) {
    // Check to make sure that functions can call one another out of order.
    // This tests the prescan.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() {"
        "        Y();"
        "        X();"
        "    }"
        "    public int32 Y() {"
        "        Y();"
        "        X();"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionCorrectReturnStatement) {
    // Check for no exception when function returns correctly.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() {"
        "        return 3 + 4;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, FunctionIncorrectReturnStatement) {
    // Check for exception when function returns incorrect type.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() {"
        "        return true;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_TYPE_MISMATCH);
    delete root;
}

TEST(SemanticAstWalker, BlockStatementScoping) {
    // Check that variables are scoped by block without being replaced.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() { "
        "        X <- 1;"
        "        { X <- true; } "
        "        X <- 2;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, PropertyReturnCorrectly) {
    // Check that returning correctly from a property does not throw.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    int32 X {"
        "        public get { return 0; }"
        "        public set { }"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, PropertyReturnFromSet) {
    // Check that returning from a setter does throw.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    int32 X {"
        "        public get { return 0; }"
        "        public set { return 0; }"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_FROM_PROPERTY_SET);
    delete root;
}

TEST(SemanticAstWalker, PropertyReturnInvalidType) {
    // Check that we throw if we try to return invalid type from a property.
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    int32 X {"
        "        public get { return true; }"
        "        public set { }"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_RETURN_TYPE_MISMATCH);
    delete root;
}

TEST(SemanticAstWalker, AddInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(int32 x) {"
        "        main(3 + 3.0);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNMATCHING_TYPE_IN_ADD);
    delete root;
}

TEST(SemanticAstWalker, AddString) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(string x) {"
        "        X(\"sfsf\" + \"sfsf\");"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, AddBool) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- true + true;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_INVALID_TYPE_IN_ADD);
    delete root;
}

TEST(SemanticAstWalker, SubtractString) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(string x) {"
        "        x <- \"sfsf\" - \"sfsf\";"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, ModString) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(string x) {"
        "        x <- \"sfsf\" % \"sfsf\";"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, MulInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- true * true;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, DivInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- true / true;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, AndInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- 3 && 3;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONBOOL_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, OrInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- 3.0 || 3.0;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONBOOL_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, GreaterInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- true > false;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, LessInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        x <- true < false;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, GreaterEqualsInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(string x) {"
        "        x <- \"h\" >= \"d\";"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, LessEqualsInvalidType) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(string x) {"
        "        x <- \"h\" <= \"d\";"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_NONNUMERIC_OPERANDS);
    delete root;
}

TEST(SemanticAstWalker, FunctionInAssign) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        foo <- X(true);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastIntToInt) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int32(3);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastIntToFloat) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- float32(3);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastIntToChar) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int8(3);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastIntToBool) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- bool(3);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastFloatToFloat) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- float32(3.0);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastFloatToInt) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int32(3.0);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastFloatToBool) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- bool(3.0);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastFloatToChar) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int8(3.0);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastBoolToBool) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- bool(true);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastBoolToFloat) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- float32(true);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastBoolToChar) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int8(true);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastBoolToInt) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int32(true);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastCharToBool) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- bool('x');"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastCharToFloat) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- float32('x');"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastCharToInt) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int32('x');"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, TypecastCharToChar) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int8('x');"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

// TODO: support this in the future, but not yet.
TEST(SemanticAstWalker, TypecastStringToInt) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 main() {"
        "        foo <- int32(\"sfsf\");"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_STATUS(semantic_walker.Walk(), STATUS_SEMANTIC_UNSUPPORTED_TYPECAST);
    delete root;
}

TEST(SemanticAstWalker, Combined) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X(bool x) {"
        "        X( ((-(-1+2) / 3)) > (0 * (4 % -5)) || !(!(3 < 2)) && (4 >= 5) && (1 <= 6));"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, AddChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int8 X() {"
        "        return 'x' + 'x';"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, SubChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int8 X() {"
        "        return 'x' - int8(7);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, MulChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int8 X() {"
        "        return int8(2.5 + float32(4)) * 'z';"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, DivChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int8 X() {"
        "        return '0' / int8(2);"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, ModChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int32 X() {"
        "        return int32('0') % 2;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}

TEST(SemanticAstWalker, StoreAndLoadChars) {
    std::string input(
        "package \"Gundersoft\";"
        "public spec Test {"
        "    public int8 X() {"
        "        x <- 'q';"
        "        y <- x;"
        "    }"
        "}");
    CompilerStringSource source(input);
    Lexer lexer(source);
    Parser parser(lexer);

    Node* root = parser.Parse();

    SemanticAstWalker semantic_walker(*root);

    EXPECT_NO_THROW(semantic_walker.Walk());
    delete root;
}