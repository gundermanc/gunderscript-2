#+TITLE: Gunderscript 2 Project Planning Document
#+AUTHOR: Christian Gunderman

This document is an Emacs Org-mode document. Open with emacs to use advanced
features and collapsing of function descriptions.

(C) 2014 Christian Gunderman

* Project Information
** Project Requirements
   Below are the basic parameters and features that Gunderscript 2 
   tentatively will implement:

   - Strongly typed language.
   - C style commenting, syntax (mostly), operators, escape sequences
     and strings.
   - Object oriented.
   - Constant values.
   - Java style class declarations:
     + Fields, constants, fields, member functions, properties.
     + Member functions live INSIDE of class body.
     + Access modifiers are required.
     + Constructors/Destructors
     + C# style property statements, they are awesome.
   - Bitwise operations.
   - Native Code interface: The ability to wrap native C functions
     by simply declaring them in Gunderscript code, perhaps like so:

   #+BEGIN_SRC C
     public native int32 FindWindow(string cName, string wName) 
        from ("user32" named "FindWindow" | internal)
   #+END_SRC
   - Fix some C/C++/Java/C# confusion points and inadequacies:
     + Assignment Statements: [type] [varname] <- [value] rather
       than using equals.
     + Atomic Swap: [var1] <-> [var2] to avoid temp variable code.
     + Comparision: [var1] = [var2] to avoid = or == problems.
     + Doc string property for each declared method, like python.
     + internal access modifier: grants access to a method ONLY to
       subclasses.
     + Allow binary constants by appending "b" to end of digits.
     + Replace typecasts with "as" keyword: "(10.5) as int32"
     + No fields, ALL class members are C# style properties:
       - Fields marked "readonly" must be set, either once in the
	 constructor, or at declaration. They cannot be modified
	 after they are set once, and the compiler will inline
	 their values automatically if they are constant numeric
	 or string values.
   - Logical Structures:
     + For loop
     + While loop
       - Else - yes, a while/else statement
     + Do while loop
     + if/else
     + switch case
     + is a statement??
   - Default params:
     Function params can be followed by "<- [value]" to give the param
     default values. Such parameters are then optional when calling
     the function.
   - Variable Types:
     + int8
     + int16
     + int32
     + int64
     + float32
     + float64
     + enums??? Maybe
     + Classes - defined in code
       * string class
     + First Class functions or interfaces of some kind.
     + Front/end backend modularity: implementor should be able to easily
       implement interpreters, code generators, optimizers, etc. Each piece
       should accept interfaces that allow for overriding of default components.

** Code Style:
   See the Google C++ coding style guidelines for more information.
* Components
** Unit Tests

    Gunderscript 1 had 0 unit tests. Yep, that's right, 0. Gunderscript 2 will
    have *too many* unit tests. Better safe than sorry this time. No code is to
    be checked into the master branch until it is accompanied by exhaustive unit
    tests.

** Gunderscript Library

    Constructed of a series of modular classes that each serve one purpose in
    the compilation process. 

*** Public APIs:
    The public API will consist of the Gunderscript class which
    will wrap the gaps between each of the compiler and runtime components.
    The Gunderscript object will expose all functionality that is available
    to applications that leverage the Gunderscript library. In addition, the
    public API will allow the user to swap backend components (code generator,
    VM, etc) with others that implement the correct interface.

*** Wrapper Classes
    Wrappers for common STL functionality such as Maps, etc. so that they are
    abstracted and can be easily replaced by alternatives in the future if
    neccessary.

*** Symbol Table
    Custom datastructure constructed of a series of hash map data structures
    used for defining symbols in blocks. Narrowing of scope is implemented by
    pushing another table. Moving from a narrow scope to a wider one is done
    by popping a table.

    Each object in the symbol table will be hashed by its string representation
    and will contain:
    + The type of the symbol (NAME, INT_CONST, FLOAT_CONST, Keyword, etc.)
    + The enum value corresponding to the symbol (if is keyword).
    + Pointers to related data:
      - Functions: function body offset in program, access modifiers, return val.
      - Variables: data section offset in program, access modifiers, type.
      - Class Defs: size, field names/types.
      - Keywords: production function related data???
*** Lexer:
    Basic functionality is finished as of this writing. Supports some basic
    types, int and float consts, names, all the Gunderscript keywords and
    symbols, and has a full suite of unit tests.

    Hand written not using regex or external libraries for maximum portability,
    slightly at the cost of performance.

*** Parser
    Performs construction of an intermediate representation. Parser will be a
    top down implementation. Will probably be recursive descent in nature, but
    may modify to make predictive. Will probably take the form of a grammar tree
    of nodes. 

    Checks for Syntax errors.

*** Semantic Analyser / Intermediate Generator
    Traverses the tree generated by the parser and eliminates grammatical
    intermediate nodes, checks for semantic errors, and ascribes meaning to the
    code. May perform annotation step.

*** Intermediate Language Generator
    Produces an intermediate representation of the Gunderscript code, dividing
    the output into basic blocks, class definitions and structures, and maybe
    performing a basic optimization pass if time allows.
*** Code Generator
    Generates output code. Default implementation will produce code for the
    Gunderscript VM in VM bytecode and will export to an external "package"
    binary. Should take into account endianness of system and export to a 
    portable,  architecture independent encoding.

*** Virtual Machine
    Gunderscript virtual machine supports dynamically loading
    and calling functions in dyload-able libraries in Windows and Linux.
    Memory management is automatic and makes use of a Mark-sweep algorithm
    and custom memory allocator to accelerate the process. 

    The current plan for the VM is to implement using NanoJIT as the backend
    and some other opensource garbage collector.

    Would like this to support multithreading, but this is a stretch goal.

*** Standard Library
    A library of standard math and string functions (and some datastructures)
    written in Gunderscript code. When neccessary, this Gunderscript code can
    import native C functions using the "native" keyword. This library will
    be a package separate from Gunderscript. May make embedding compiled library
    a compile option through a custom Makefile target.

*** Standard Errors
    All Gunderscript errors will decend from the Exception class. Each
    module in Gunderscript has it's own exception parent type from which it's
    exceptions descend. Each error should have it's own exception.

    In this way, we can simply catch Exception (the Gunderscript class, not
    the STL one) and we automatically catch all of the Gunderscript errors.

*** Constants
    Defines all constants widely used in Gunderscript, including the VM OP codes.
** Gunderscript Command Line Application
   Leverages the Gunderscript Static Library to provide command line scripting
   functionality.
* Gunderscript 2 Grammar

  Below are the in-progress grammar candidates for the Gunderscript language.
  For the purposes of simply hammering out the structure, these grammars are
  not constrained to a particular family yet.

** Prototype Grammar

   As much of the grammar as I have currently developed. Will need to be
   refactored to LL(1) before implementation of parser.

   Credit to Tim Henderson: Portions of this grammar are copied from or inspired
   by bits of Arrow Lang: http://compilers.hackthology.com

   #+BEGIN_SRC

   TOKENS:
     Keywords = {

       AccessModifiers = {
         "concealed", "public", "internal", "package"
       },

       "spec", "if", "else", "do", "while", "true", "false", "return",
       "package", "get", "set", "value", "constant", "conceive", "eradicate",
       "start", "readonly"

       // NOTE: The types presented below are the desired types, but they will
       // not be implemented until AFTER the "Base Functionality" milestone is
       // reached. In the meantime, we have char, int, bool, string, float.
       Types = {
        "int8", "int16", "int32", "int64", "float32", "float64",
        "bool", "string"
       }
     }

     Symbols = {
       "<-", "<->", "==", "+", "-", "*", "/", "%", "(", ")", "{", "}", "[",
       "]", "<", ">", ".", ";", ",", "|", "&", "!", ">=", "<=", "&&", "||",
       "<<", ">>", "+=", "-=", "*=", "/=", "%=", "++", ":"
     }

     --------------- Borrowed from compilers.hackthology.com -------------

     NAME ([a-z]|[A-Z])([a-z]|[A-Z]|[0-9]|_)*
     INT_CONST [0-9]+
     FLOAT_CONST [0-9]*\\.?[0-9]+((E|e)(\\+|-)?[0-9]+)?

     whitespace ( |\t|\n)
     line comment (\/\/^\n

     STRING_CONST

     Must start with '"' and end with the first non-escaped '"'. A quote can
     be escaped with a slash, '\"'. Valid strings:

        "aa\"\"" --> aa""
        "aa\\" --> aa\
        "aa\\\\" --> aa\\

     c-style range comment ....

     Similar to strings. Must start with '/*' and end with '*/'. However, '*'
     or '/' can be escaped as in strings. Valid c-style range comments

        /* asfde */
        /* awef \*/ */
        /* woief oiwjer*\/ awie */

     Whitespace and comments should be skipped (although line and column numbers
     should be tracked).

    ----------------------------------------------------------------------

    GRAMMAR:
     CodeFileBeginning     -> "package" STRING_CONST ";" CodeFileBody

     CodeFileBody          -> ClassDef 
                            | CodeFileBody
                            | e            

     ClassDef              -> ClassHeader "{" ClassBody "}"

     ClassHeader           -> AccessModifier "spec" NAME

     ParamDeclList         -> ParamDeclList*
                            | e

     ParamDeclList*        -> ParamDeclList* "," Param
                            | Param

     Param                 -> Type NAME ParamInit

     ParamInit             -> "<-" Constant

     ClassBody             -> StartDecl
                            | FunctionDecl
                            | PropertyDecl
                            | ConstructorDecl
                            | DestructorDecl
                            | ClassBody
                            | e 

     StartDecl             -> "start" "(" "string" "[" "]" NAME ")" BlockStmt

     ConstructorDecl       -> AccessModifier "conceive" "(" ParamDeclList ")" BlockStmt

     DestructorDecl        -> AccessModifier "eradicate" "(" ")" BlockStmt

     FieldDecl             -> AccessModifier Type NAME VarInit ";"

     VarInit               -> "<-" Expr
                            | e

     FunctionDecl          -> AccessModifier NativeProp Type NAME "(" ParamDeclList ")" BlockStmt

     NativeProp            -> "native"
                            | e

     TypeProp              -> Type
                            | e

     BlockBody             -> Statement BlockBody
                            | Statement
                            | e

     Statement             -> DeclStmt
                            | BlockStmt
                            | IfStmt
                            | WhileStmt
                            | DoWhileStmt
                            | ForStmt
                            | CallExpr
                            | AssignExpr
                            | Return stmt
                            | ";"

     Expr                  -> CallExpr
                            | AssignExpr
                            | BooleanExpr
                            | ArithExpr
                            | MultExpr

     Constant              -> INT_CONST
                            | STRING_CONST
                            | FLOAT_CONST
                            | BooleanConst

     PropertyDecl          -> Type NAME "{" PropertyBody "}"

     PropertyBody          -> GetProp SetProp
                            | SetProp GetProp

     GetProp               -> AccessModifier "get" ";"
                            | AccessModifier "get" BlockStmt

     SetProp               -> AccessModifier "set" ";"
                            | AccessModifier "set" BlockStmt

     DeclStmt              -> ConstProp Type NAME ";"

     ConstProp             -> "constant"
                            | e

     BlockStmt             -> "{" BlockBody "}"

     IfStmt                -> "if" "(" Expr ")" "{" BlockBody "}"
                            | "if" "(" Expr ")" Statement else Statement

     WhileStmt             -> "while" "(" Expr ")" Statement

     DoWhile               -> "do" Statement "while" "(" Expr ")" ";"

     ForStmt               -> "for" "(" Expr ";" Expr ";" Expr ")" Statement

     ReturnStmt            -> "return" Expr;

     CallExpr              -> NAME "(" ParamCallList ")"

     AssignExpr            -> NAME "<-" Expr;

     BooleanExpr           TBD..

     ArithExpr             TBD..

     MultExpr              TBD..

     BooleanConst          -> true
                            | false

     ParamCallList         -> ParamCallList*
                            | e

     ParamDeclList*        -> ParamCallList* "," Param
                            | Param

     CallParam             -> NAME
                            | NAME ":" NAME
   #+END_SRC
