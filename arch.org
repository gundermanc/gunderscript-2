#+TITLE: Gunderscript 2 Project Planning Document
#+AUTHOR: Christian Gunderman

This document is an Emacs Org-mode document. Open with emacs to use advanced
features and collapsing of function descriptions.

(C) 2014 Christian Gunderman

* Project Information
** Project Requirements
   Below are the basic parameters and features that Gunderscript 2 
   tentatively will implement:

   - C style commenting, syntax (mostly), operators, escape sequences
     and strings.
   - Object oriented.
   - Constant values.
   - Java style class declarations:
     + Fields, constants, fields, member functions, properties.
     + Member functions live INSIDE of class body.
     + Access modifiers are required.
     + Constructors/Destructors
     + Arguments require type, however variables infer types.
     + C# style property statements, they are awesome.
   - Bitwise operations.
   - Native Code interface: The ability to wrap native C functions
     by simply declaring them in Gunderscript code, perhaps like so:

   #+BEGIN_SRC C
     public native int FindWindow(string cName, string wName) 
        from ("user32" named "FindWindow" | internal)
   #+END_SRC
   - Fix some C/C++/Java/C# confusion points and inadequacies:
     + Assignment Statements: [type] [varname] <- [value] rather
       than using equals.
     + Atomic Swap: [var1] <-> [var2] to avoid temp variable code.
     + Comparision: [var1] = [var2] to avoid = or == problems.
     + Doc string property for each declared method, like python.
     + posterity access modifier: grants access to a method ONLY to
       subclasses.
     + No semicolons.
   - Logical Structures:
     + For loop
     + While loop
       - Else - yes, a while/else statement
     + Do while loop
     + if/else
     + switch case
     + is a statement??
   - Variable Types:
     + int8
     + int16
     + int32
     + int64
     + float32
     + float64
     + enums??? Maybe
     + Classes - defined in code
       * string class
     + First Class functions or interfaces of some kind.
     + Front/end backend modularity: implementor should be able to easily
       implement interpreters, code generators, optimizers, etc. Each piece
       should accept interfaces that allow for overriding of default components.

** Code Style:
   See the Google C++ coding style guidelines for more information.
* Components
** Unit Tests

    Gunderscript 1 had 0 unit tests. Yep, that's right, 0. Gunderscript 2 will
    have *too many* unit tests. Better safe than sorry this time. No code is to
    be checked into the master branch until it is accompanied by exhaustive unit
    tests.

** Gunderscript Library

    Constructed of a series of modular classes that each serve one purpose in
    the compilation process. 

*** Public APIs:
    The public API will consist of the Gunderscript class which
    will wrap the gaps between each of the compiler and runtime components.
    The Gunderscript object will expose all functionality that is available
    to applications that leverage the Gunderscript library. In addition, the
    public API will allow the user to swap backend components (code generator,
    VM, etc) with others that implement the correct interface.

*** Lexer:
    Performs Lexing operation and returns tokens in some format along
    with token types. Ideally implement using regular expressions, but if the
    C++ STL doesn't have the neccessary functionality, I intend to implement
    a modified Thompson Regex Compiler and VM for deterministic finite
    automata if time allows. Might just settle for non-deterministic
    implementation. Returns error if unterminated comment, string, char, etc.
    is encountered, but does no syntax or semantic analysis. Tracks line numbers.

*** Parser
    Performs construction of an intermediate representation. Parser will be a
    top down implementation. Will probably be recursive descent in nature, but
    may modify to make predictive. Will probably take the form of a grammar tree
    of nodes. 

    Checks for Syntax errors.

*** Semantic Analyser / Intermediate Generator
    Traverses the tree generated by the parser and eliminates grammatical
    intermediate nodes, checks for syntax errors, and ascribes meaning to the
    code. 

*** Code Generator
    Generates output code. Default implementation will produce code for the
    Gunderscript VM.

*** Virtual Machine
    Gunderscript register based virtual machine. Supports dynamically loading
    and calling functions in dyload-able libraries. Memory management is
    automatic and makes use of a Mark-sweep algorithm and custom memory
    allocator to accelerate the process. Function stack is maintained in
    internal VM stack.

*** Standard Library
    A library of standard math and string functions (and some datastructures)
    written in Gunderscript code. When neccessary, this Gunderscript code can
    import native C functions using the "external" keyword. This library will
    be a package separate from Gunderscript. May make embedding compiled library
    a compile option.

*** Standard Errors
    A class containing all error codes and code to obtain their associated error
    messages.

*** Constants
    Defines all constants widely used in Gunderscript, including the VM OP codes.
** Gunderscript Command Line Application
   Leverages the Gunderscript Static Library to provide command line scripting
   functionality.
* Gunderscript 2 Grammar

  Below are the in-progress grammar candidates for the Gunderscript language.
  For the purposes of simply hammering out the structure, these grammars are
  not constrained to a particular family yet.

** Prototype Grammar

   As much of the grammar as I have currently developed. Will need to be
   refactored to LL(1) before implementation of parser.

   Credit to Tim Henderson: Portions of this grammar are copied from or inspired
   by bits of Arrow Lang: http://compilers.hackthology.com

   #+BEGIN_SRC

   TOKENS:
     Keywords = {

       AccessModifiers = {
         "private", "public", "internal", "posterity"
       },

       "class", "if", "else", "do", "while", "true", "false", "return",
       "package", "get", "set", "value", "constant"

       Types = {
        "int8", "int16", "int32", "int64", "float32", "float64",
        "bool"
       }
     }

     Symbols = {
       "<-", "<->", "==", "+", "-", "*", "/", "%", "(", ")", "{", "}", "[",
       "]", "<", ">", ".", ";", ",", "|", "&", "!", ">=", "<=", "&&", "||",
       "<<", ">>", "+=", "-=", "*=", "/=", "%=", "++", ":"
     }

     NAME ([a-z]|[A-Z])([a-z]|[A-Z]|[0-9]|_)*
     INT_CONST [0-9]+
     FLOAT_CONST [0-9]*\\.?[0-9]+((E|e)(\\+|-)?[0-9]+)?

     whitespace ( |\t|\n)
     line comment (\/\/^\n

     STRING_CONST

     Must start with '"' and end with the first non-escaped '"'. A quote can
     be escaped with a slash, '\"'. Valid strings:

        "aa\"\"" --> aa""
        "aa\\" --> aa\
        "aa\\\\" --> aa\\

     c-style range comment ....

     Similar to strings. Must start with '/*' and end with '*/'. However, '*'
     or '/' can be escaped as in strings. Valid c-style range comments

        /* asfde */
        /* awef \*/ */
        /* woief oiwjer*\/ awie */

     Whitespace and comments should be skipped (although line and column numbers
     should be tracked).

    GRAMMAR:
     CodeFileBeginning     -> "package" STRING_CONST ";" CodeFileBody

     CodeFileBody          -> ClassDef 
                            | CodeFileBody
                            | e            

     ClassDef              -> ClassHeader "{" ClassBody "}"

     ClassHeader           -> AccessModifier "class" NAME "(" ParamDeclList ")"

     ParamDeclList         -> ParamDeclList*
                            | e

     ParamDeclList*        -> ParamDeclList* "," Param
                            | Param

     Param                 -> Type NAME ParamInit

     ParamInit             -> "<-" Constant

     ClassBody             -> FieldDecl
                            | FunctionDecl
                            | PropertyDecl
                            | ClassBody
                            | e 

     FieldDecl             -> AccessModifier Type NAME VarInit ";"

     VarInit               -> "<-" Expr
                            | e

     FunctionDecl          -> AccessModifier NativeProp Type NAME "(" ParamDeclList ")" BlockStmt

     NativeProp            -> "native"
                            | e

     TypeProp              -> Type
                            | e

     BlockBody             -> Statement BlockBody
                            | Statement
                            | e

     Statement             -> DeclStmt
                            | BlockStmt
                            | IfStmt
                            | WhileStmt
                            | DoWhileStmt
                            | ForStmt
                            | CallExpr
                            | AssignExpr
                            | Return stmt
                            | ";"

     Expr                  -> CallExpr
                            | AssignExpr
                            | BooleanExpr
                            | ArithExpr
                            | MultExpr

     Constant              -> INT_CONST
                            | STRING_CONST
                            | FLOAT_CONST
                            | BooleanConst

     PropertyDecl          -> Type NAME "{" PropertyBody "}"

     PropertyBody          -> GetProp SetProp
                            | SetProp GetProp

     GetProp               -> AccessModifier "get" ";"
                            | AccessModifier "get" BlockStmt

     SetProp               -> AccessModifier "set" ";"
                            | AccessModifier "set" BlockStmt

     DeclStmt              -> ConstProp Type NAME ";"

     ConstProp             -> "constant"
                            | e

     BlockStmt             -> "{" BlockBody "}"

     IfStmt                -> "if" "(" Expr ")" "{" BlockBody "}"
                            | "if" "(" Expr ")" Statement else Statement

     WhileStmt             -> "while" "(" Expr ")" Statement

     DoWhile               -> "do" Statement "while" "(" Expr ")" ";"

     ForStmt               -> "for" "(" Expr ";" Expr ";" Expr ")" Statement

     ReturnStmt            -> "return" Expr;

     CallExpr              -> NAME "(" ParamCallList ")"

     AssignExpr            -> NAME "<-" Expr;

     BooleanExpr           TBD..

     ArithExpr             TBD..

     MultExpr              TBD..

     BooleanConst          -> true
                            | false

     ParamCallList         -> ParamCallList*
                            | e

     ParamDeclList*        -> ParamCallList* "," Param
                            | Param

     CallParam             -> NAME
                            | NAME ":" NAME
   #+END_SRC
