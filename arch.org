#+TITLE: Gunderscript 2 Project Planning Document
#+AUTHOR: Christian Gunderman

This document is an Emacs Org-mode document. Open with emacs to use advanced
features and collapsing of function descriptions.

(C) 2014 Christian Gunderman

* Project Information
** Project Requirements
   Below are the basic parameters and features that Gunderscript 2 
   tentatively will implement:

   - C style commenting, syntax (mostly), operators, escape sequences
     and strings.
   - Object oriented.
   - Constant values.
   - Java style class declarations:
     + Fields, constants, fields, member functions, properties.
     + Member functions live INSIDE of class body.
     + Access modifiers are required.
     + Constructors/Destructors
     + Arguments require type, however variables infer types.
     + C# style property statements, they are awesome.
   - Bitwise operations.
   - Native Code interface: The ability to wrap native C functions
     by simply declaring them in Gunderscript code, perhaps like so:

   #+BEGIN_SRC C
     public native int FindWindow(string cName, string wName) 
        from ("user32" | this) named "FindWindow"
   #+END_SRC
   - Fix some C/C++/Java/C# confusion points and inadequacies:
     + Assignment Statements: [type] [varname] <- [value] rather
       than using equals.
     + Atomic Swap: [var1] <-> [var2] to avoid temp variable code.
     + Comparision: [var1] = [var2] to avoid = or == problems.
     + Doc string property for each declared method, like python.
     + posterity access modifier: grants access to a method ONLY to
       subclasses.
     + No semicolons.
   - Logical Structures:
     + For loop
     + While loop
       - Else - yes, a while/else statement
     + Do while loop
     + if/else
     + switch case
     + is a statement??
   - Variable Types:
     + int8
     + int16
     + int32
     + int64
     + float32
     + float64
     + enums??? Maybe
     + Classes - defined in code
       * string class
     + First Class functions or interfaces of some kind.
     + Front/end backend modularity: implementor should be able to easily
       implement interpreters, code generators, optimizers, etc. Each piece
       should accept interfaces that allow for overriding of default components.

** Code Style:
   See the Google C++ coding style guidelines for more information.
* Components
** Unit Tests

    Gunderscript 1 had 0 unit tests. Yep, that's right, 0. Gunderscript 2 will
    have *too many* unit tests. Better safe than sorry this time. No code is to
    be checked into the master branch until it is accompanied by exhaustive unit
    tests.

** Gunderscript Library

    Constructed of a series of modular classes that each serve one purpose in
    the compilation process. 

*** Public APIs:
    The public API will consist of the Gunderscript class which
    will wrap the gaps between each of the compiler and runtime components.
    The Gunderscript object will expose all functionality that is available
    to applications that leverage the Gunderscript library. In addition, the
    public API will allow the user to swap backend components (code generator,
    VM, etc) with others that implement the correct interface.

*** Lexer:
    Performs Lexing operation and returns tokens in some format along
    with token types. Ideally implement using regular expressions, but if the
    C++ STL doesn't have the neccessary functionality, I intend to implement
    a modified Thompson Regex Compiler and VM for deterministic finite
    automata if time allows. Might just settle for non-deterministic
    implementation. Returns error if unterminated comment, string, char, etc.
    is encountered, but does no syntax or semantic analysis.

*** Parser
    Performs construction of an intermediate representation. Parser will be a
    top down implementation. Will probably be recursive descent in nature, but
    may modify to make predictive. Will probably take the form of a grammar tree
    of nodes. 

    Checks for Syntax errors.

*** Semantic Analyser / Intermediate Generator
    Traverses the tree generated by the parser and eliminates grammatical
    intermediate nodes, checks for syntax errors, and ascribes meaning to the
    code. 

*** Code Generator
    Generates output code. Default implementation will produce code for the
    Gunderscript VM.

*** Virtual Machine
    Gunderscript register based virtual machine. Supports dynamically loading
    and calling functions in dyload-able libraries.

*** Standard Library
    A library of standard math and string functions (and some datastructures)
    written in Gunderscript code. When neccessary, this Gunderscript code can
    import native C functions using the "external" keyword. This library will
    be a package separate from Gunderscript. May make embedding compiled library
    a compile option.

*** Standard Errors
    A class containing all error codes and code to obtain their associated error
    messages.

*** Constants
    Defines all constants widely used in Gunderscript, including the VM OP codes.
